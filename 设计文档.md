# 🧬 Project Quine: Java 自进化算法引擎 (MVP 设计文档)



版本: v0.1 (Alpha)

代号: "Darwin's Sandbox" (达尔文沙箱)

目标: 构建一个 Java 运行时环境，使一段代码（排序算法）能够在不重启 JVM 的情况下，通过 LLM 的变异和评估，自动从 $O(n^2)$ 进化为 $O(n \log n)$。

------



## 1. 核心架构视图 (System Architecture)



系统由三个核心模块组成，构成一个死循环（The Loop）：

1. **Phenotype (表现型 / 被实验体):** 实现特定接口的 Java 源代码。
2. **Mutator (变异器 / 上帝):** 负责读取源码，调用 LLM 进行修改，并回写文件。
3. **Evaluator (评估器 / 自然选择):** 负责动态编译新代码，加载运行，并根据性能打分。

代码段

```
graph TD
    A[Start: 初始代码 (BubbleSort)] --> B(Mutator: LLM 变异);
    B --> C{Evaluator: 编译 & 加载};
    C -- 编译失败 --> D[死亡 (Discard)];
    D --> B;
    C -- 编译成功 --> E{Arena: 运行测试};
    E -- 结果错误 --> D;
    E -- 结果正确 --> F[Benchmark: 性能评分];
    F -- 分数变低 --> D;
    F -- 分数变高 --> G[进化成功! (Replace)];
    G --> B;
```

------



## 2. 关键组件设计 (Component Design)





### 2.1. 基因接口 (The Gene Interface)



为了保证“变异”后的怪物还能被系统识别，必须定义一个不可变的接口。

Java

```
package com.quine.core;

public interface TaskSolver {
    /**
     * 核心任务：对数组进行排序
     * @param input 乱序数组
     * @return 有序数组
     */
    int[] solve(int[] input);
}
```



### 2.2. 初始物种 (The Seed)



一个故意写得很烂的实现类，作为进化的起点。

- **文件名:** `TargetSubject.java`
- **内容:** 标准冒泡排序 (Bubble Sort)。
- **位置:** `src/main/java/com/quine/sandbox/` (独立包，方便热加载)



### 2.3. 变异引擎 (The Mutator)



- **职责:** I/O 操作 + LLM 调用。

- **Prompt 策略:**

  > "你是一个 Java 代码优化专家。请阅读以下代码，优化其算法复杂度以提升性能。
  >
  > 约束：
  >
  > 1. 必须实现 `TaskSolver` 接口。
  > 2. 类名必须保持为 `TargetSubject`。
  > 3. 只返回 Java 代码，不要 Markdown，不要解释。"



### 2.4. 动态编译器 (The Runtime Compiler) **[核心难点]**



这是本项目的技术壁垒。不能用 `javac` 命令行，要用 API。

- **技术栈:** `javax.tools.JavaCompiler`
- **内存编译 (In-Memory Compilation):**
  - 为了速度，不要把 `.class` 写死在硬盘上，最好直接编译到内存字节数组 (`byte[]`) 中。
  - *MVP 阶段妥协：* 如果内存编译太难，先编译到临时文件夹 `target/generations/gen_X/` 也可以。



### 2.5. 热加载器 (The Hot-Swapper)



- **技术栈:** `java.net.URLClassLoader`
- **机制:**
  - JVM 的类加载机制决定了同一个 ClassLoader 不能重复加载同名类。
  - **破局:** 每一代 (Generation) 变异，都 `new` 一个新的 `URLClassLoader` 实例去加载它。用完即扔（便于 GC 回收，防止 Metaspace 爆炸）。

------



## 3. 详细流程逻辑 (The Logic Flow)





### 阶段一：初始化 (Genesis)



1. 加载 `TargetSubject.java` 的初始版本。
2. 生成一个巨大的随机数组（例如 100,000 个整数）作为测试集 `TEST_DATA`。
3. 运行初始版本，记录 `baselineTime` (例如 5000ms)。



### 阶段二：进化循环 (The Loop)



**Loop (Generation 1 to N):**

1. **Mutation (变异):**
   - 读取 `TargetSubject.java` 源码字符串。
   - 请求 LLM API (Qwen/DeepSeek)，获取 `newSourceCode`。
2. **Compilation (编译):**
   - 调用 `JavaCompiler` 编译 `newSourceCode`。
   - **Catch:** 如果编译报错 -> 记录日志 "Gen X: Compile Error"，**跳过本轮**。
3. **Loading (加载):**
   - `ClassLoader loader = new URLClassLoader(...)`
   - `Class<?> cls = loader.loadClass("com.quine.sandbox.TargetSubject")`
   - `TaskSolver mutant = (TaskSolver) cls.newInstance()`
4. **Verification (验尸):**
   - **正确性测试:** 用一个小数组 `[5, 3, 1]` 跑一遍。如果结果不是 `[1, 3, 5]` -> 记录日志 "Gen X: Logic Error"，**跳过本轮**。
   - **性能测试:** 用 `TEST_DATA` 跑一遍，记录 `newTime`。
5. **Selection (自然选择):**
   - `if (newTime < baselineTime)`:
     - **进化成功！**
     - 覆盖源代码文件：`writeFile("TargetSubject.java", newSourceCode)`
     - 更新基准：`baselineTime = newTime`
     - 输出高亮日志：**"🎉 Evolution Success! Speed up: " + (old - new) + "ms"**
   - `else`:
     - 进化失败（性能倒退），丢弃。

------



## 4. 技术栈选型 (Tech Stack)



- **语言:** Java 21 (为了更好的 String Template 和虚拟线程支持)。
- **LLM SDK:** `LangChain4j` (推荐) 或直接用 `OkHttp` 手搓 DeepSeek API 调用。
- **测试框架:** 不用 JUnit (为了 MVP 的轻量化，直接在 main 函数里写 `if` 判断)，或者用 `JUnit 5`。
- **编译 API:** JDK 自带 `javax.tools`。
- **外部依赖:** 0 (除了 LLM SDK)。保持极致轻量。

------



## 5. 风险与对策 (Risk Management)



| **风险点**       | **现象**                                              | **解决方案**                                                 |
| ---------------- | ----------------------------------------------------- | ------------------------------------------------------------ |
| **死循环**       | AI 生成了 `while(true)`，卡死主线程                   | 使用 `ExecutorService` + `Future.get(1, TimeUnit.SECONDS)` 设置超时强杀。 |
| **幻觉代码**     | AI 引入了不存在的第三方库 (如 `import org.apache...`) | 在 Prompt 里强调：**“只能使用 JDK 标准库”**。                |
| **类加载泄露**   | 跑了 1000 代后 OOM (Metaspace溢出)                    | 确保每一代测试完后，将 `mutant` 对象置为 `null`，并 `close()` 掉 ClassLoader。 |
| **代码格式错乱** | LLM 返回了 Markdown 包裹的代码                        | 写一个简单的 `Regex` 清洗器，把 ````java` 和 ````` 去掉。    |

------



## 6. MVP 验证成功的标准 (Definition of Done)



当你运行 `Main.java`，不需要任何人工干预，控制台自动打印出类似日志时，视为 MVP 成功：

Plaintext

```
[System] Starting Evolution... Baseline BubbleSort: 4500ms
[Gen 1] Compiling... Success. Testing... Failed (Result Incorrect).
[Gen 2] Compiling... Failed (Syntax Error).
[Gen 3] Compiling... Success. Testing... Logic OK.
[Gen 3] Benchmark: 2100ms.
[System] ⚡ EVOLUTION DETECTED! Replacing Source Code. New Baseline: 2100ms.
...
[Gen 8] ...
[System] ⚡ EVOLUTION DETECTED! New Baseline: 15ms. (AI switched to Arrays.sort)
```

------



## 7. 给你的行动指令 (Action Items)



1. **今晚:** 创建项目 `Project-Quine`。
2. **第一步:** 手写 `CompilerUtils` 工具类，跑通“读取 String -> 编译成 Class -> 反射调用”这个流程。这是最难的一步。
3. **第二步:** 接入 LLM API，测试能不能让它把冒泡排序改写成别的。
4. **第三步:** 把循环串起来。

**这就是你的“火种”。去点燃它吧。**