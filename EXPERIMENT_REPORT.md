# Project Quine: Java 自进化算法引擎实验报告

## 1. 实验概述

### 1.1 实验目标

验证通过 LLM（大语言模型）驱动的代码变异和自然选择机制，能否使排序算法在运行时自动从低效实现（O(n²)）进化为高效实现（O(n log n)），且整个过程无需人工干预。

### 1.2 实验假设

- H1: LLM 能够理解代码并生成有意义的优化变异
- H2: 通过性能选择压力，算法会向更优方向进化
- H3: 进化过程会呈现渐进式特征，而非一步到位

### 1.3 实验环境

| 项目 | 配置 |
|------|------|
| 操作系统 | Windows 11 |
| Java 版本 | OpenJDK 25.0.1 |
| LLM 模型 | qwen3-coder-plus |
| LLM 温度 | 1.0 |
| 测试数据规模 | 10,000 个随机整数 |
| 最大进化代数 | 200 代 |
| 性能容差 | 5%（允许中性变异存活） |

## 2. 系统架构

### 2.1 核心组件

```
┌─────────────────────────────────────────────────────────────┐
│                     进化循环 (Evolution Loop)                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌──────────┐    ┌──────────┐    ┌──────────┐             │
│   │ Mutator  │───>│ Compiler │───>│Evaluator │             │
│   │ (LLM)    │    │ (动态)   │    │ (选择)   │             │
│   └──────────┘    └──────────┘    └──────────┘             │
│        │                               │                    │
│        │         ┌──────────┐          │                    │
│        └────────>│ 源代码   │<─────────┘                    │
│                  │ (基因)   │   (性能更优则替换)            │
│                  └──────────┘                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 进化流程

1. **变异 (Mutation)**: LLM 读取当前代码，生成优化变异
2. **编译 (Compilation)**: 使用 javax.tools.JavaCompiler 动态编译
3. **验证 (Verification)**: 正确性测试（4 个测试用例）
4. **评估 (Evaluation)**: 性能基准测试（3 次预热 + 5 次测量取平均）
5. **选择 (Selection)**: 性能更优或在容差范围内则保留

### 2.3 选择策略

```java
// 自然选择（允许 5% 以内的性能波动）
double tolerance = 1.05;
if (result.timeUs <= baselineTime * tolerance) {
    // 保留变异
}
```

| 性能变化 | 结果 | 说明 |
|---------|------|------|
| 更快 | 保留 | 进化成功 |
| 慢 ≤5% | 保留 | 中性变异（保留多样性） |
| 慢 >5% | 丢弃 | 性能倒退 |

## 3. 实验结果

### 3.1 性能进化数据

| 代数 | 性能 (ms) | 变化 | 算法类型 | 事件 |
|------|-----------|------|----------|------|
| 初始 | 40.67 | - | 冒泡排序 | 起点 |
| Gen 1 | 38.08 | -6.4% | 优化冒泡 | 进化成功 |
| Gen 2 | 38.16 | +0.2% | - | 中性变异 |
| Gen 4 | 39.85 | +4.2% | - | 中性变异 |
| Gen 5 | 37.19 | -6.7% | 希尔排序 | 进化成功 |
| Gen 15 | 35.11 | -5.6% | - | 进化成功 |
| Gen 21 | 34.63 | -1.4% | - | 进化成功 |
| Gen 27 | 32.33 | -6.6% | Introsort | 进化成功 |
| Gen 28-135 | - | - | - | 停滞期 (108代) |
| Gen 136 | 33.36 | +3.1% | - | 中性变异 |
| Gen 139 | 32.08 | -3.8% | - | 进化成功 |
| Gen 145 | 26.77 | -16.5% | 优化快排 | 进化成功 |
| Gen 146-200 | - | - | - | 停滞期 |

### 3.2 总体统计

| 指标 | 值 |
|------|-----|
| 初始性能 | 40.67 ms |
| 最终性能 | 26.77 ms |
| **总提升** | **34.2%** |
| **加速比** | **1.52x** |
| 总代数 | 200 |
| 成功进化 | 8 次 |
| 中性变异 | 2 次 |
| 编译失败 | 7 次 |
| 性能倒退 | 183 次 |
| 成功率 | 5% (10/200) |

### 3.3 性能进化曲线

```
性能 (ms)
    │
 45 ┤
    │
 40 ┤ ●━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    │  ↘ Gen 1: 优化冒泡
 35 ┤    ●━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    │     ↘ Gen 5: 希尔排序
 30 ┤       ●━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    │        ↘ Gen 27: Introsort
 25 ┤          ●━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    │                                    ↘ Gen 145: 优化快排
 20 ┤                                      ●━━━━━━━━━━━━━━━
    │
    └──┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──→ 代数
       0     25     50     75    100    125    150    175   200
```

## 4. 算法进化分析

### 4.1 进化路径

```
阶段 1: 冒泡排序优化
┌─────────────────────────────────────────────────────────────┐
│ 初始: 冒泡排序 (Bubble Sort)                                │
│ 复杂度: O(n²)                                               │
│                                                             │
│ for (int i = 0; i < n - 1; i++) {                          │
│     for (int j = 0; j < n - i - 1; j++) {                  │
│         if (arr[j] > arr[j + 1]) swap(arr, j, j+1);        │
│     }                                                       │
│ }                                                           │
└─────────────────────────────────────────────────────────────┘
                              ↓ Gen 1
┌─────────────────────────────────────────────────────────────┐
│ Gen 1: 优化冒泡排序                                         │
│ 优化: 添加 swapped 标志，提前退出                           │
│                                                             │
│ for (int i = 0; i < n - 1; i++) {                          │
│     boolean swapped = false;                // ← 新增       │
│     for (int j = 0; j < n - i - 1; j++) {                  │
│         if (arr[j] > arr[j + 1]) {                         │
│             swap(arr, j, j+1);                              │
│             swapped = true;                 // ← 新增       │
│         }                                                   │
│     }                                                       │
│     if (!swapped) break;                    // ← 新增       │
│ }                                                           │
└─────────────────────────────────────────────────────────────┘

阶段 2: 算法跃迁
                              ↓ Gen 5
┌─────────────────────────────────────────────────────────────┐
│ Gen 5: 希尔排序 (Shell Sort)                                │
│ 复杂度: O(n^1.3) ~ O(n^1.5)                                 │
│ 特征: Knuth 序列 (gap = gap*3+1)                            │
│                                                             │
│ int gap = 1;                                                │
│ while (gap < n / 3) gap = gap * 3 + 1;                     │
│ while (gap >= 1) {                                          │
│     for (int i = gap; i < n; i++) {                        │
│         // 间隔插入排序                                     │
│     }                                                       │
│     gap /= 3;                                               │
│ }                                                           │
└─────────────────────────────────────────────────────────────┘

阶段 3: 工业级算法
                              ↓ Gen 27
┌─────────────────────────────────────────────────────────────┐
│ Gen 27: Introsort (内省排序)                                │
│ 复杂度: O(n log n) 保证                                     │
│ 组成: 快速排序 + 堆排序 + 插入排序                          │
│                                                             │
│ introsort(arr, 0, n-1, 2 * log2(n));                       │
│                                                             │
│ - 小数组 (≤16): 插入排序                                   │
│ - 递归深度超限: 堆排序兜底                                  │
│ - 正常情况: 快速排序 + 三数取中                             │
└─────────────────────────────────────────────────────────────┘

阶段 4: 简化优化
                              ↓ Gen 145
┌─────────────────────────────────────────────────────────────┐
│ Gen 145: 优化快排 (简化版)                                  │
│ 复杂度: O(n log n) 平均                                     │
│                                                             │
│ - 移除堆排序兜底 (简化代码)                                 │
│ - 保留三数取中 (pivot 选择)                                 │
│ - 保留小数组插入排序                                        │
│ - 尾递归优化 (减少栈深度)                                   │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 算法复杂度对比

| 算法 | 最好 | 平均 | 最坏 | 空间 |
|------|------|------|------|------|
| 冒泡排序 | O(n) | O(n²) | O(n²) | O(1) |
| 希尔排序 | O(n log n) | O(n^1.3) | O(n²) | O(1) |
| Introsort | O(n log n) | O(n log n) | O(n log n) | O(log n) |
| 优化快排 | O(n log n) | O(n log n) | O(n²) | O(log n) |

## 5. 关键发现

### 5.1 进化停滞现象

实验观察到两个明显的停滞期：

| 停滞期 | 代数范围 | 持续代数 | 突破点 |
|--------|----------|----------|--------|
| 第一次 | Gen 28-135 | 108 代 | Gen 136 中性变异 |
| 第二次 | Gen 146-200 | 55 代 | 未突破 |

**分析**: 当算法达到局部最优时，LLM 难以找到更优的变异方向。中性变异机制（5% 容差）帮助系统跳出第一个局部最优。

### 5.2 中性变异的价值

| 中性变异 | 后续影响 |
|----------|----------|
| Gen 2 (+0.2%) | 为 Gen 5 希尔排序铺路 |
| Gen 4 (+4.2%) | 保持多样性 |
| Gen 136 (+3.1%) | 为 Gen 139/145 突破铺路 |

**结论**: 中性变异虽然不直接提升性能，但保持了种群多样性，为后续突破创造条件。

### 5.3 LLM 变异特征

| 特征 | 观察 |
|------|------|
| 算法知识 | LLM 能生成希尔排序、Introsort 等高级算法 |
| 渐进优化 | 大部分变异是小步改进，偶尔有算法跃迁 |
| 错误率 | 7/200 = 3.5% 编译失败率 |
| 创造性 | 能组合多种优化技术（三数取中、尾递归等） |

### 5.4 简化也是优化

Gen 145 相比 Gen 27 (Introsort) 移除了堆排序兜底机制，但性能反而提升了 16.5%。

**原因分析**:
1. 测试数据是随机分布，快排不会退化
2. 堆排序的常数因子较大
3. 代码简化减少了分支判断开销

## 6. 实验结论

### 6.1 假设验证

| 假设 | 结论 | 证据 |
|------|------|------|
| H1: LLM 能生成有意义的优化 | **验证** | 生成了希尔排序、Introsort 等高级算法 |
| H2: 性能选择压力驱动进化 | **验证** | 性能从 40.67ms 降至 26.77ms |
| H3: 进化呈渐进式特征 | **部分验证** | 有渐进优化，也有算法跃迁 |

### 6.2 主要成果

1. **性能提升 34.2%**: 从 40.67ms 降至 26.77ms
2. **算法复杂度跃迁**: 从 O(n²) 进化到 O(n log n)
3. **自主发现高级算法**: LLM 自主"发现"了 Introsort（C++ STL 使用的算法）
4. **中性变异机制有效**: 帮助系统跳出局部最优

### 6.3 局限性

1. **依赖 LLM 的算法知识**: LLM 本身已经"知道"这些排序算法
2. **测试数据单一**: 仅使用随机数据，未测试特殊分布
3. **进化效率较低**: 200 代中仅 5% 成功
4. **无法保证全局最优**: 可能陷入局部最优

### 6.4 未来改进方向

1. **多样性种群**: 维护多个并行进化的个体
2. **自适应变异**: 根据停滞代数调整变异幅度
3. **多目标优化**: 同时考虑时间、空间、稳定性
4. **交叉变异**: 引入两个个体的代码交叉

## 7. 附录

### 7.1 最终进化代码

```java
package com.quine.sandbox;

import com.quine.core.TaskSolver;

public class TargetSubject implements TaskSolver {
    @Override
    public int[] solve(int[] input) {
        int[] arr = input.clone();
        int n = arr.length;

        if (n <= 1) {
            return arr;
        }

        optimizedSort(arr, 0, n - 1);
        return arr;
    }

    private void optimizedSort(int[] arr, int left, int right) {
        while (left < right) {
            if (right - left < 16) {
                insertionSort(arr, left, right);
                return;
            }

            int pivotIndex = medianOfThree(arr, left, right);
            swap(arr, pivotIndex, right);

            int partitionIndex = partition(arr, left, right);

            if (partitionIndex - left < right - partitionIndex) {
                optimizedSort(arr, left, partitionIndex - 1);
                left = partitionIndex + 1;
            } else {
                optimizedSort(arr, partitionIndex + 1, right);
                right = partitionIndex - 1;
            }
        }
    }

    private int medianOfThree(int[] arr, int left, int right) {
        int mid = (left + right) >>> 1;
        if (arr[left] > arr[mid]) swap(arr, left, mid);
        if (arr[mid] > arr[right]) swap(arr, mid, right);
        if (arr[left] > arr[mid]) swap(arr, left, mid);
        return mid;
    }

    private int partition(int[] arr, int left, int right) {
        int pivot = arr[right];
        int i = left - 1;

        for (int j = left; j < right; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, right);
        return i + 1;
    }

    private void insertionSort(int[] arr, int low, int high) {
        for (int i = low + 1; i <= high; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= low && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 7.2 LLM 提示词

```
你是一个算法优化专家。请对以下排序代码进行改进。

改进策略（按优先级）：
1. 可以对现有算法进行优化（如添加提前退出、减少比较次数、减少交换次数）
2. 可以尝试相近的算法变体（如冒泡排序→鸡尾酒排序→梳排序）
3. 可以逐步引入更高效的思想（如引入"间隔"概念、分区思想、递归分治）
4. 如果当前算法已经很难优化，可以尝试更高效的排序算法

注意：
- 每次改动要有明确的优化意图
- 尽量渐进式改进，避免一步跳跃太大
- 不要添加任何注释

严格约束：
1. 必须实现 TaskSolver 接口
2. 类名必须保持为 TargetSubject
3. 包名必须是 com.quine.sandbox
4. 绝对禁止使用 java.util.Arrays、java.util.Collections 等标准库的排序方法
5. 只能使用基础 JDK 类（如 System、Math），不要引入第三方依赖
6. 只返回完整的 Java 代码，不要 Markdown 代码块，不要解释
```

### 7.3 实验日期

2025 年 11 月 30 日

---

